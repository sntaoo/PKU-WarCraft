- 如何组织输出系统
  - 5分时遍历所有城市，令狮子逃跑
    - 狮子输出
    - 城市中移除战士
  - 10分时遍历城市，令武士前进
    - 武士如何前进？
      - 从左往右遍历城市向量，调用对应武士的march函数(如在城市i调用i+1的蓝武士的前进函数)
      - 如果是第0个城市，只会发生蓝军到达行为，所以，如果城市一有蓝军，输出蓝军前进，再输出蓝军抢占司令部，结束游戏
      - 如果是第一个城市，红军刚刚制造的武士会到达，城市二的蓝军也会到达。
        - 注意保存next_move_red,因为左边过来的红武士会覆盖右边城市的红武士
        - 或者随时更新城市0和城市n+1的内容
      - 如果是第n个城市,城市n-1的红军会到达，蓝军刚刚制造的武士也会到达
      - 如果是第n+1个城市，检查next_move_red是否为nullptr,如果不是，说明红军要抢占司令部
      - 如果判断是nullptr,则不做输出
  - 35分时，从左到右遍历城市，如果发现有狼，做出狼抢占武器的操作（如果都是狼，则不做操作）
    - 抢占武器前，需要对武器做排序和筛除，注意抢武器的规则，序号最小的那种，最多持有10件，弓箭抢夺顺序等
    - 抢夺武器后，对武器重新排序
  - 40分时，进行战斗
    - 遍历所有城市
      - 如果有两个武士，要进行战斗，把二者推入战斗函数，返回战斗结果
        - 循环攻击，除非至少有一方死亡或者双方武器均使用完，或者双方血量不再变化，否则停止战斗
        - 只有活着才能发动攻击
        - 战斗停止后，如果是一方获胜的结果，胜方缴获败方的武器
        - 如果龙存活，龙要欢呼
      - 定义一个Enum,表示战斗的结果
  - 50分时，报告司令部生命值
  - 55分时，从左到右，先红后蓝报告武器情况

- 武士死亡
  - 战斗失败的武士会死亡，死亡直接在战斗结果出来后，把城市武士置为空即可(delete)
- event_system静态成员变量定义
  - 红/蓝是否被占领


- 武士的march函数
  - 获得所在城市变量和前进方向
  - 输出，判断是否占领了司令部
  - 改变武士所在城市序号
  - 雪人move需要减少血量,狮子move需要减少忠诚度
  - 放置指针的操作放在函数外
  
- 武器的攻击函数
  - 定义武器子类，实现特性和攻击函数
    - 不得定义武器攻击力属性
    - bomb使用一次后消失，定义变量unusable
    - arrow可以使用两次，使用两次后消失，定义变量use_count
    - 攻击函数写为虚函数，各子类继承修改。void attack(warrior* attacker, warrior* injure)
  
- 如何组织武士的武器？
  - 每个战士的武器集都是一个vector,
    - 当使用了一个炸弹后，将炸弹的不可使用置为true，使用炸弹之前，判断不可使用为false
    - 每当使用一把弓箭一次后，弓箭的use_count++, 使用弓箭之前，判断use_count < 2
    - 战斗结束后，对自己的武器进行排序与筛除，筛除后不可delete，除非亲自书写析构函数
  
- 城市如何组织？
  - 组织城市为一个vector<pair<red_warrior*, blue_warrior*>>, 

- 如何制造武士？
  - 如往常一样，但是制造完成后，保留最新制造武士的指针cur_maked_blue

- 重写战士类
  - 武器为基类的成员变量，还有武器的排序函数
  - march函数设置为虚函数，添加所在城市(int)成员变量
  - 龙不再有moral,但是龙会yell

- 写一个时间转换格式的函数，时间系统的时间每次走五分钟
- 武士的制造也变为如果不够制造该制造的武士，就从此停止制造武士，需要重写
- 新造出来的战士放到第0个或第n+1个的对应位置上

- 内存优化：改为右值引用并重写析构函数
- 定义几个全局对象，让使用的全部去引用该对象